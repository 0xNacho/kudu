// Copyright (c) 2013, Cloudera, inc.

#ifndef KUDU_TABLET_CLOCK_H_
#define KUDU_TABLET_CLOCK_H_

#include <inttypes.h>
#include <string>

#include "gutil/ref_counted.h"

namespace kudu {
class faststring;
class MonoDelta;
class Slice;
class Status;
namespace tablet {
class txid_t;

// An interface for a clock that can be used to assign timestamps to
// operations.
// Implementations must respect the following assumptions:
// 1 - Now() must return monotonically increasing numbers
//     i.e. for any two calls, i.e. Now returns txid1 and txid2, it must
//     hold that txid1 < txid2.
// 2 - Update() must never set the clock backwards (corollary of 1)
class Clock : public base::RefCountedThreadSafe<Clock> {
 public:
  // Obtains a new transaction timestamp corresponding to the current instant.
  virtual txid_t Now() = 0;

  // Update the clock with a transaction timestamp originating from
  // another server. For instance replicas can call this so that,
  // if elected leader, they are guaranteed to generate timestamps
  // higher than the timestamp of the last transaction accepted from the
  // leader.
  virtual Status Update(const txid_t& to_update) = 0;

  // Waits until the clock advances to 'then'.
  // Can also be used to implement 'external consistency' in the same sense as
  // Google's Spanner.
  virtual Status WaitUntilAfter(const txid_t& then) = 0;

  // Behaves like the above method but waits until the clock advances to 'then'
  // for a maximum time of 'max'. If the clock has not reached the requested
  // timestamp by max returns Status::TimedOut.
  virtual Status TimedWaitUntilAfter(const txid_t& then, const MonoDelta& max) = 0;

  virtual ~Clock() {}
};

// A transaction timestamp generated by Clock.
class txid_t {
 public:
  typedef uint64_t val_type;

  txid_t() : v(kInvalidTxId.v) {}

  explicit txid_t(uint64_t val) : v(val) {}

  bool operator ==(const txid_t &other) const {
    return v == other.v;
  }

  // Decode a txid from the given input slice.
  // Mutates the slice to point after the decoded txid.
  // Returns true upon success.
  bool DecodeFrom(Slice *input);

  // Encode the txid to the given buffer.
  void EncodeTo(faststring *dst) const;

  int CompareTo(const txid_t &other) const;

  std::string ToString() const;

  // Encodes this txid_t and appends it to the provided string.
  void EncodeToString(std::string* encode_to) const;

  Status DecodeFromString(const std::string& decode_from);

  val_type value() const { return v; }

  // An initial transaction id, higher than min so that we can have
  // a txid_t guaranteed to be lower than all generated txids.
  static const txid_t kInitialTxId;

  // An invalid transaction ID -- txid_t types initialize to this variable.
  static const txid_t kInvalidTxId;

  // The maximum txid.
  static const txid_t kMax;

  // The minimum txid.
  static const txid_t kMin;

 private:
  val_type v;
};

inline std::ostream &operator <<(std::ostream &o, const txid_t &txid) {
  return o << txid.ToString();
}

} // namespace tablet
} // namespace kudu

#endif /* KUDU_TABLET_CLOCK_H_ */
