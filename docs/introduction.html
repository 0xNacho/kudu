---
title: Introducing Kudu
layout: default

last_updated: 'Last updated 2015-09-10 14:14:51 PDT'
---


<div class="container">
  <div class="row">
    <div class="col-md-9">

<h1>Introducing Kudu</h1>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Kudu is a columnar storage manager developed for the Hadoop platform.  Kudu shares
the common technical properties of Hadoop ecosystem applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Runs on commodity hardware</p>
</li>
<li>
<p>Horizontally scalable</p>
</li>
<li>
<p>Supports highly available operation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kudu&#8217;s design sets it apart. Some of Kudu&#8217;s benefits include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fast processing of OLAP workloads.</p>
</li>
<li>
<p>Integration with MapReduce, Spark and other Hadoop ecosystem components.</p>
</li>
<li>
<p>Tight integration with Cloudera Impala, making it a good, mutable alternative
to using HDFS with Parquet.</p>
</li>
<li>
<p>Strong but flexible consistency model, allowing you to choose consistency
requirements on a per-request basis, including the option for strict
serialized consistency.</p>
</li>
<li>
<p>Strong performance for running sequential and random workloads simultaneously.</p>
</li>
<li>
<p>Easy to administer and manage with Cloudera Manager.</p>
</li>
<li>
<p>High availability. Tablet Servers and Master use the <a href="#raft">Raft Consensus Algorithm</a>, which ensures
availability even if <em>f</em> nodes failing, given <em>2f+1</em> nodes in the cluster.
Reads can be serviced by read-only follower tablets, even in the event of a
leader tablet failure.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By combining all of these properties, Kudu targets support for families of
applications that are difficult or impossible to implement on current generation
Hadoop storage technologies. A few examples of applications for which Kudu is a great
solution are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reporting applications where newly-arrived data needs to be immediately available for end users</p>
</li>
<li>
<p>Time-series applications that must simultaneously support:</p>
<div class="ulist">
<ul>
<li>
<p>queries across large amounts of historic data</p>
</li>
<li>
<p>granular queries about an individual entity that must return very quickly</p>
</li>
</ul>
</div>
</li>
<li>
<p>Applications that use predictive models to make real-time decisions with periodic
refreshes of the predictive model based on all historic data</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information about these and other scenarios, see <a href="#kudu_use_cases">Example Use Cases</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_concepts_and_terms"><a class="link" href="#_concepts_and_terms">Concepts and Terms</a></h2>
<div class="sectionbody">
<div id="kudu_columnar_data_store" class="paragraph">
<div class="title">Columnar Data Store</div>
<p>Kudu is a <em>columnar data store</em>. A columnar data store stores data in strongly-typed
columns. With a proper design, it is superior for analytical or data warehousing
workloads for several reasons.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Read Effiency</dt>
<dd>
<p>For analytical queries, you can read a single column, or a portion
of that column, while ignoring other columns. This means you can fulfill your query
while reading a minimal number of blocks on disk. With a row-based store, you need
to read the entire row, even if you only return values from a few columns.</p>
</dd>
<dt class="hdlist1">Data Compression</dt>
<dd>
<p>Because a given column contains only one type of data, pattern-based
compression can be orders of magnitude more efficient than compressing mixed data
types. Combined with the efficiencies of reading data from columns,  compression allows
you to fulfill your query while reading even fewer blocks from disk.</p>
</dd>
</dl>
</div>
<div id="raft" class="paragraph">
<div class="title">Raft Consensus Algorithm</div>
<p>The <a href="http://raftconsensus.github.io/">Raft consensus algorithm</a> provides a
way to elect a <em>leader</em> for a distributed cluster from a pool of potential
leaders, or <em>candidates</em>. Other cluster members are <em>followers</em>, who are not
candidates or leaders, but always look to the current leader for consensus. Kudu
uses the Raft Consensus Algorithm for the election of masters and leader
tablets, as well as determining the success or failure of a given write
operation.</p>
</div>
<div class="paragraph">
<div class="title">Table</div>
<p>A <em>table</em> is where your data is stored in Kudu. A table has a schema and
a totally ordered primary key. A table is split into segments called tablets, by
primary key.</p>
</div>
<div class="paragraph">
<div class="title">Tablet</div>
<p>A <em>tablet</em> is a contiguous segment of a table. A given tablet is
replicated on multiple tablet servers, and one of these replicas is considered
the leader tablet. Any replica can service reads, and writes require consensus
among the set of tablet servers serving the tablet.</p>
</div>
<div class="paragraph">
<div class="title">Tablet Server</div>
<p>A <em>tablet server</em> stores and serves tablets to clients. For a
given tablet, one tablet server serves the lead tablet, and the others serve
follower replicas of that tablet. Only leaders service write requests, while
leaders or followers each service read requests. Leaders are elected using
<a href="#raft">Raft Consensus Algorithm</a>. One tablet server can serve multiple tablets, and one tablet can be served
by multiple tablet servers.</p>
</div>
<div class="paragraph">
<div class="title">Master</div>
<p>The <em>master</em> keeps track of all the tablets, tablet servers, the
<a href="#catalog_table">Catalog Table</a>, and other metadata related to the cluster. At a given point
in time, there can only be one acting master (the leader). If the current leader
disappears, a new master is elected using <a href="#raft">Raft Consensus Algorithm</a>.</p>
</div>
<div class="paragraph">
<p>The master also coordinates metadata operations for clients. For example, when
creating a new table, the client internally sends an RPC to the master. The
master writes the metadata for the new table into the catalog table, and
coordinates the process of creating tablets on the tablet servers.</p>
</div>
<div class="paragraph">
<p>All the master&#8217;s data is stored in a tablet, which can be replicated to all the
other candidate masters.</p>
</div>
<div class="paragraph">
<p>Tablet servers heartbeat to the master at a set interval (the default is once
per second).</p>
</div>
<div id="catalog_table" class="paragraph">
<div class="title">Catalog Table</div>
<p>The <em>catalog table</em> is the central location for
metadata of Kudu. It stores information about tables and tablets. The catalog
table is accessible to clients via the master, using the client API.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Tables</dt>
<dd>
<p>table schemas, locations, and states</p>
</dd>
<dt class="hdlist1">Tablets</dt>
<dd>
<p>the list of existing tablets, which tablet servers have replicas of
each tablet, the tablet&#8217;s current state, and start and end keys.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<div class="title">Logical Replication</div>
<p>Kudu replicates operations, not on-disk data. This is referred to as <em>logical
replication</em>, as opposed to <em>physical replication</em>. Physical operations, such as
compaction, do not need to transmit the data over the network. This results in a
substantial reduction in network traffic for heavy write scenarios.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_architectural_overview"><a class="link" href="#_architectural_overview">Architectural Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>INSERT DIAGRAM HERE</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kudu_use_cases"><a class="link" href="#kudu_use_cases">Example Use Cases</a></h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Streaming Input with Near Real Time Availability</div>
<p>TODO give an example of how Kudu helps here.</p>
</div>
<div class="paragraph">
<div class="title">Time-series application with widely varying access patterns</div>
<p>TODO give an example of how Kudu helps here.</p>
</div>
<div class="paragraph">
<div class="title">Iterative predictive learning</div>
<p>TODO give an example of how Kudu helps here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_steps"><a class="link" href="#_next_steps">Next Steps</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="quickstart.html">Get Started With Kudu</a></p>
</li>
<li>
<p><a href="installation.html">Kudu Installation Guide</a></p>
</li>
</ul>
</div>
</div>
</div>
    </div>
    <div class="col-md-3">

  <div id="toc" data-spy="affix" data-offset-top="70">
    <ul class="sectlevel1">
<li><a href="#_concepts_and_terms">Concepts and Terms</a></li>
<li><a href="#_architectural_overview">Architectural Overview</a></li>
<li><a href="#kudu_use_cases">Example Use Cases</a></li>
<li><a href="#_next_steps">Next Steps</a></li>
</ul>
  </div>
    </div>
  </div>
</div>