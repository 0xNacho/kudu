// Copyright (c) 2013, Cloudera, inc.
//
// Protobufs used by both client-server and server-server traffic
// for user data transfer. This file should only contain protobufs
// which are exclusively used on the wire. If a protobuf is persisted on
// disk and not used as part of the wire protocol, it belongs in another
// place such as common/common.proto or within cfile/, server/, etc.
package kudu;

import "common/common.proto";

// Error status returned by any RPC method.
// Every RPC method which could generate an application-level error
// should have this (or a more complex error result) as an optional field
// in its response.
//
// This maps to kudu::Status in C++.
message AppStatusPB {
  enum ErrorCode {
    OK = 0;
    NOT_FOUND = 1;
    CORRUPTION = 2;
    NOT_SUPPORTED = 3;
    INVALID_ARGUMENT = 4;
    IO_ERROR = 5;
    ALREADY_PRESENT = 6;
    RUNTIME_ERROR = 7;
    NETWORK_ERROR = 8;
    ILLEGAL_STATE = 9;
    NOT_AUTHORIZED = 10;
    ABORTED = 11;
    REMOTE_ERROR = 12;
    SERVICE_UNAVAILABLE = 13;
    TIMED_OUT = 14;
    UNKNOWN_ERROR = 999;
  }

  required ErrorCode code = 1;
  optional string message = 2;
  optional int32 posix_code = 4;
}

// Uniquely identify a particular instance of a particular server in the
// cluster.
message NodeInstancePB {
  // Unique ID which is created when the server is first started
  // up. This is stored persistently on disk.
  required bytes permanent_uuid = 1;

  // Sequence number incremented on every start-up of the server.
  // This makes it easy to detect when an instance has restarted (and
  // thus can be assumed to have forgotten any soft state it had in
  // memory).
  //
  // On a freshly initialized server, the first sequence number
  // should be 0.
  required int64 instance_seqno = 2;
}

message ColumnBlockPB {
  required ColumnSchemaPB schema = 1;

  // Bitmap of where the null cells fall, only set on nullable
  // columns.
  optional bytes null_bitmap = 2;

  // The column data.
  //
  // This is the raw in-memory (little-endian) form of the data for
  // the column. Any pointers within this data should be relative to
  // the beginning of 'indirect_data'.
  //
  // TODO: later this should get moved to a "sidecar" like HBase to
  // avoid copies in/out of std::strings in the protobuf library.
  required bytes data = 3;

  // Storage for any "indirect" data types in the block. For example,
  // STRING values in the block will be stored using the normal Slice
  // in-memory format, except that instead of being pointers in RAM,
  // the pointer portion will be an offset into this protobuf field.
  optional bytes indirect_data = 4;
}

// A row block in which each row is stored contiguously.
message RowwiseRowBlockPB {
  repeated ColumnSchemaPB schema = 1;

  // TODO: the number of key columns doesn't actually make sense
  // in the context of row-blocks, since we may ask to scan a projection
  // which doesn't include the key, or the columns in the projection may
  // be in a different order. Will remove this field in a later commit.
  optional int32 num_key_columns = 2;

  // The number of rows in the block. This can typically be calculated
  // by dividing rows.size() by the width of the row, but in the case that
  // the client is scanning an empty projection (i.e a COUNT(*)), this
  // field is the only way to determine how many rows were returned.
  optional int32 num_rows = 3 [ default = 0 ];

  // The rows of data. Each row is stored in the same in-memory format
  // as kudu::ContigiousRow (i.e a null bitmap followed by the raw unencoded
  // data).
  //
  // The data for NULL cells will be present with undefined contents --
  // typically it will be filled with \x00s but this is not guaranteed,
  // and clients may choose to initialize NULL cells with whatever they
  // like. Setting to some constant improves RPC compression, though.
  //
  // Any pointers are made relative to the beginning of 'indirect_data'.
  optional bytes rows = 4;

  // See ColumnBlockPB.indirect_data.
  optional bytes indirect_data = 5;
}
