// Copyright (c) 2013, Cloudera, inc.

#ifndef KUDU_TABLET_CLOCK_H_
#define KUDU_TABLET_CLOCK_H_

#include <inttypes.h>
#include <string>

#include "gutil/ref_counted.h"

namespace kudu {
class faststring;
class MonoDelta;
class Slice;
class Status;
namespace tablet {
class Timestamp;

// An interface for a clock that can be used to assign timestamps to
// operations.
// Implementations must respect the following assumptions:
// 1 - Now() must return monotonically increasing numbers
//     i.e. for any two calls, i.e. Now returns timestamp1 and timestamp2, it must
//     hold that timestamp1 < timestamp2.
// 2 - Update() must never set the clock backwards (corollary of 1)
class Clock : public base::RefCountedThreadSafe<Clock> {
 public:
  // Obtains a new transaction timestamp corresponding to the current instant.
  virtual Timestamp Now() = 0;

  // Update the clock with a transaction timestamp originating from
  // another server. For instance replicas can call this so that,
  // if elected leader, they are guaranteed to generate timestamps
  // higher than the timestamp of the last transaction accepted from the
  // leader.
  virtual Status Update(const Timestamp& to_update) = 0;

  // Waits until the clock advances to 'then'.
  // Can also be used to implement 'external consistency' in the same sense as
  // Google's Spanner.
  virtual Status WaitUntilAfter(const Timestamp& then) = 0;

  // Behaves like the above method but waits until the clock advances to 'then'
  // for a maximum time of 'max'. If the clock has not reached the requested
  // timestamp by max returns Status::TimedOut.
  virtual Status TimedWaitUntilAfter(const Timestamp& then, const MonoDelta& max) = 0;

  virtual ~Clock() {}
};

// A transaction timestamp generated by Clock.
class Timestamp {
 public:
  typedef uint64_t val_type;

  Timestamp() : v(kInvalidTimestamp.v) {}

  explicit Timestamp(uint64_t val) : v(val) {}

  bool operator ==(const Timestamp &other) const {
    return v == other.v;
  }

  // Decode a timestamp from the given input slice.
  // Mutates the slice to point after the decoded timestamp.
  // Returns true upon success.
  bool DecodeFrom(Slice *input);

  // Encode the timestamp to the given buffer.
  void EncodeTo(faststring *dst) const;

  int CompareTo(const Timestamp &other) const;

  std::string ToString() const;

  // Encodes this Timestamp and appends it to the provided string.
  void EncodeToString(std::string* encode_to) const;

  Status DecodeFromString(const std::string& decode_from);

  val_type value() const { return v; }

  // An initial transaction timestamp, higher than min so that we can have
  // a Timestamp guaranteed to be lower than all generated timestamps.
  static const Timestamp kInitialTimestamp;

  // An invalid transaction ID -- Timestamp types initialize to this variable.
  static const Timestamp kInvalidTimestamp;

  // The maximum timestamp.
  static const Timestamp kMax;

  // The minimum timestamp.
  static const Timestamp kMin;

 private:
  val_type v;
};

inline std::ostream &operator <<(std::ostream &o, const Timestamp &timestamp) {
  return o << timestamp.ToString();
}

} // namespace tablet
} // namespace kudu

#endif /* KUDU_TABLET_CLOCK_H_ */
