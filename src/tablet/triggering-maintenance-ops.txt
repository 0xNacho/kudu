TODO: this document is work-in-progress

Random thoughts on how to decide when to run maintenance operations
------------------------------------------------------------

For the purpose of this doc, "maintenance operations" are any background
processes that Kudu runs in the course of normal operation. Every type of
maintenance operation has some cost-benefit tradeoff -- for example, running
a compaction will spend some I/O now in order to speed up insertions later.
Running a flush will cost I/O in order to free memory.

Generally, we need some kind of policy for determining when to run maintenance
operations, and which ones to run. This document has some ideas on how to do this.


Maintenance operations to reduce memory usage
----------------------------------------

These operations spend some I/O or CPU in order to free up memory usage. They
may also incur further performance costs after completion. These cannot be
delayed indefinitely, as RAM is a finite resource.


MemStore Flush
------------------------------
Cost:
- Sequential I/O now (writing the actual memstore contents to disk)
- Sequential I/O later (frequent small flushes will cost more compactions down the road)

Benefit:
- RAM: frees up memory

Other/wash:
- At first glance, flushing might seem to increase cost of further insert/updates
  because it adds a new RowSet. However, because memstores are not compressed in
  any way, typically the newly flushed RowSet will be much smaller on disk than the
  memstore that it came from. This means that, even if we have to cache the whole
  result RowSet in the block cache, we're making much more effective use of RAM and
  thus may _reduce_ the total number of actual I/Os.


DeltaMemStore Flush
------------------------------
Basically the same costs as MemStore flush

Additional benefits:
TODO: flushing may also speed up scans substantially. Need to run experiments on this --
how much better is scanning a static cached file compared to scanning the equivalent
memstore. Maybe an order of magnitude.


LRU cache eviction
------------------------------
Cost: slower reads, slower inserts if evicting key columns or blooms
Benefit: frees RAM




Maintenance operations to manage future performance
----------------------------------------

These operations expend some kind of I/O and CPU now in order to improve the performance
of the system after they complete. They are only ever "necessary" in that if we put them
off forever, the system will slow to a crawl eventually.


Merging Compaction
------------------------------
Cost:
- Sequential I/O now (reading input, re-writing output)

Benefit:
- reduce the number of RowSets: speeds up inserts, updates. Speeds up short scans where blooms don't apply.


Minor Delta Compaction
------------------------------
Cost:
- Sequential I/O (reading input, re-writing output)

Benefit:
- Speeds up scans -- fewer delta trackers to apply
- May save disk space (eg when snapshot isolation is implemented, old version updates may be discarded)


Major delta compaction
------------------------------
Cost:
- Sequential I/O (reading input, re-writing output)

Benefit:
- Speeds up scans -- fewer delta trackers to apply, fewer total rows with deltas to apply.
- Save disk space (eg when snapshot isolation is implemented, old version updates may be discarded)

Relevant metrics:
- for each column, % of rows in RowSet which have been updated
- for each column, % of deltas which could be fully merged
- workload: scan heavy vs insert/update heavy?

