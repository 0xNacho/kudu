// Copyright 2014 Cloudera inc.
// Confidential Cloudera Information: Covered by NDA.

#ifndef KUDU_CODEGEN_JIT_SCHEMA_PAIR_H
#define KUDU_CODEGEN_JIT_SCHEMA_PAIR_H

#include "kudu/codegen/jit_owner.h"
#include "kudu/codegen/row_projector.h"
#include "kudu/gutil/gscoped_ptr.h"
#include "kudu/gutil/macros.h"
#include "kudu/gutil/ref_counted.h"

namespace llvm {
class ExecutionEngine;
}

namespace kudu {

class faststring;
class Schema;

namespace codegen {

// A JITSchemaPair is a JITCodeOwner that is specialized for owning
// jitted code and pointers to functions within that code that
// pertain to a pair of schemas for projection; i.e., it houses all
// functions that relate to projecting from a base schema to a projection
// schema. A "schema pair" refers to the ordered pair of schemas (base schema,
// projection schema).
//
// Because it is a JITCodeOwner, a reference to a JITSchemaPair guarantees
// validity of its contained functions.
//
// The key defined by a schema pair satisfies the following contract:
// if the key generated by two schema pairs is the same, then the codegen
// functions created by the two shemas will be functionally equivalent.
// This respects the equivalence defined by ProjectionsCompatible() below.
class JITSchemaPair : public JITCodeOwner {
 public:
  JITSchemaPair(gscoped_ptr<llvm::ExecutionEngine> engine,
                const RowProjector::CodegenFunctions& rp_functions);

  const RowProjector::CodegenFunctions& row_projector_functions() const {
    return rp_functions_;
  }

  // Generates a key for a pair of schemas that is unique for different
  // projection functions (if two different pairs of schemas would have the
  // same codegenned functions, then the keys they generate may not be unique).
  // See implementation of ProjectionsCompatible.
  //
  // Appends the key to 'out' iff successful.
  //
  // Failure can occur if the projection defined by (base, proj) is not
  // well defined.
  static Status EncodeKey(const Schema& base, const Schema& proj,
                          faststring* out);

  // TODO make this in the cc file only, do a check in the getters
  // This method defines what makes (base, projection) schema pairs compatible.
  // In other words, this method can be thought of as the equivalence relation
  // on the set of all well-formed (base, projection) schema pairs that
  // partitions the set into equivalence classes which will have the exact
  // same projection function code.
  //
  // This equivalence relation can be decomposed as:
  //
  //   ProjectionsCompatible(base1, proj1, base2, proj2) :=
  //     WELLFORMED(base1, proj1) &&
  //     WELLFORMED(base2, proj2) &&
  //     PROJEQUALS(base1, base2) &&
  //     PROJEQUALS(proj1, proj2) &&
  //     MAP(base1, proj1) == MAP(base2, proj2)
  //
  // where WELLFORMED checks that a projection is well-formed (i.e., a
  // kudu::RowProjector can be initialized with the schema pair), PROJEQUAL
  // is a relaxed version of the Schema::Equals() operator that is
  // independent of column names and column IDs, and MAP addresses
  // the actual dependency on column identification - which is the effect
  // that those attributes have on the RowProjector's mapping (i.e., different
  // names and IDs are ok, so long as the mapping is the same). Note that
  // key columns are not given any special meaning in projection. Types
  // and nullability of columns must be exactly equal between the two
  // schema pairs.
  //
  // Status::OK corresponds to true in the equivalence relation and other
  // statuses correspond to false, explaining why the projections are
  // incompatible.
  static Status ProjectionsCompatible(const Schema& base1, const Schema& proj1,
                                      const Schema& base2, const Schema& proj2);

 private:
  virtual ~JITSchemaPair();

  RowProjector::CodegenFunctions rp_functions_;

  DISALLOW_COPY_AND_ASSIGN(JITSchemaPair);
};

} // namespace codegen
} // namespace kudu

#endif
