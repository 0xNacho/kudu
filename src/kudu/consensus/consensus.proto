// Copyright (c) 2013, Cloudera, inc.
package kudu.consensus;

import "kudu/common/common.proto";
import "kudu/common/wire_protocol.proto";
import "kudu/server/metadata.proto";
import "kudu/tablet/tablet.proto";
import "kudu/tserver/tserver_admin.proto";
import "kudu/tserver/tserver.proto";

// Consensus-specific errors use this protobuf
message ConsensusErrorPB {
  enum Code {
    // An error which has no more specific error code.
    // The code and message in 'status' may reveal more details.
    //
    // RPCs should avoid returning this, since callers will not be
    // able to easily parse the error.
    UNKNOWN_ERROR = 1;

    // Invalid term.
    // Sent by peers in response to leader RPCs whenever the term
    // of one of the messages sent in a batch is lower than the
    // the term the peer is expecting.
    INVALID_TERM = 2;

    // For leader election.
    // The last OpId logged by the candidate is older than the last OpId logged
    // by the local peer.
    LAST_OPID_TOO_OLD = 3;

    // For leader election.
    // The local replica has already voted for another candidate in this term.
    ALREADY_VOTED = 4;

    // The replica does not recognize the caller's request as coming from a
    // member of the quorum.
    NOT_IN_QUORUM = 5;
  }

  // The error code.
  required Code code = 1 [ default = UNKNOWN_ERROR ];

  // The Status object for the error. This will include a textual
  // message that may be more useful to present in log messages, etc,
  // though its error code is less specific.
  required AppStatusPB status = 2;
}


// ===========================================================================
//  Generic/Meta- Messages
// ===========================================================================

// An id for a generic state machine operation. Composed of the leaders' term
// plus the index of the operation in that term, e.g., the <index>th operation
// of the <term>th leader.
message OpId {
  // The term of an operation or the leader's sequence id.
  required uint64 term = 1;
  required uint64 index = 2;
}

// This PB is used to serialize all of the persistent state needed for
// Consensus that is not in the WAL, such as leader election and
// communication on startup.
message ConsensusMetadataPB {
  // Last-committed quorum membership.
  required kudu.metadata.QuorumPB committed_quorum = 1;

  // Latest term this server has seen.
  // When a quorum is first created, initialized to 0.
  //
  // Whenever a new election is started, the candidate increments this by one
  // and requests votes from peers.
  //
  // If any RPC or RPC response is received from another node containing a term higher
  // than this one, the server should step down to FOLLOWER and set its current_term to
  // match the caller's term.
  //
  // If a follower receives an UpdateConsensus RPC with a term lower than this
  // term, then that implies that the RPC is coming from a former LEADER who has
  // not realized yet that its term is over. In that case, we will reject the
  // UpdateConsensus() call with ConsensusErrorPB::INVALID_TERM.
  //
  // If a follower receives a RequestConsensusVote() RPC with an earlier term,
  // the vote is denied.
  required uint64 current_term = 2;

  // Permanent UUID of the candidate voted for in 'current_term', or not present
  // if no vote was made in the current term.
  optional string voted_for = 3;
}

// ===========================================================================
//  External Consensus Messages
// ===========================================================================

// The types of operations that need a commit message, i.e. those that require
// at least one round of the consensus algorithm.
enum OperationType {
  NO_OP = 1;
  OP_ABORT = 2;
  WRITE_OP = 3;
  ALTER_SCHEMA_OP = 4;
  CHANGE_CONFIG_OP = 5;
}

// The transaction driver type: indicates whether a transaction is
// being executed on a leader or a replica.
enum DriverType {
  LEADER = 1;
  REPLICA = 2;
}

// A configuration change request for the tablet with 'tablet_id'.
message ChangeConfigRequestPB {
  required bytes tablet_id = 1;

  // The old config seqno to perform CAS style quorum config changes.
  optional int64 old_config = 2;

  // The new configuration to set the quorum to.
  required kudu.metadata.QuorumPB new_config = 3;
}

// The configuration change response. If any immediate error occurred
// the 'error' field is set with it.
message ChangeConfigResponsePB {
  optional tserver.TabletServerErrorPB error = 1;
}

// A Replicate message, sent to replicas by leader to indicate this operation must
// be stored in the WAL/SM log, as part of the first phase of the two phase
// commit.
message ReplicateMsg {
  required OpId id = 1;
  required OperationType op_type = 2;
  optional tserver.WriteRequestPB write_request = 3;
  optional tserver.AlterSchemaRequestPB alter_schema_request = 4;
  optional ChangeConfigRequestPB change_config_request = 5;

  optional NoOpRequestPB noop_request = 999;
}

// A commit message for a previous operation.
// This is a commit in the consensus sense and may abort/commit any operation
// that required a consensus round.
message CommitMsg {
  required OperationType op_type = 1;
  // the id of the message this commit pertains to
  optional OpId commited_op_id = 2;
  // The transaction timestamp for the operation.
  // This is present for all COMMITs, but not necessarily on ABORTs.
  optional fixed64 timestamp = 3;
  // The operations that were applied and/or failed in this transaction.
  optional tablet.TxResultPB result = 4;
  // The response to the write request, will contain the global status
  // (OK or otherwise) and the row errors, if any.
  optional tserver.WriteResponsePB write_response = 5;
  // The response to the alter schema request
  optional tserver.AlterSchemaResponsePB alter_schema_response = 6;
  optional ChangeConfigResponsePB change_config_response = 7;

  optional NoOpResponsePB noop_response = 999;
}

// ===========================================================================
//  Internal Consensus Messages and State
// ===========================================================================

// NoOp requests, mostly used in tests.
message NoOpRequestPB {
 // Allows to set a dummy payload, for tests.
 optional bytes payload_for_tests = 1;
}

// NoOp responses, mostly used in tests.
message NoOpResponsePB {
   // Allows to set a dummy payload, for tests.
   optional bytes payload_for_tests = 1;
}

message PerOpErrorPB {
  // The id of the operation that failed in the other peer.
  required OpId id = 1;
  // The Status explaining why the operation failed.
  required AppStatusPB status = 2;
}

// Status message received in the peer responses.
message ConsensusStatusPB {

  // The last message received (and replicated) by the peer.
  required OpId last_received = 1;

  // Per operation errors.
  repeated PerOpErrorPB per_op_errors = 6;

  // When the last request failed for some consensus related (internal) reason.
  // In some cases the error will have a specific code that the caller will
  // have to handle in certain ways.
  optional ConsensusErrorPB error = 7;
}

// A request from a CANDIDATE peer that wishes to become leader of
// the quorum serving tablet with 'tablet_id'.
// See RAFT sec. 5.2.
message VoteRequestPB {
  // Identifies the tablet quorum a the vote is being requested for.
  required string tablet_id = 1;

  // The uuid of the sending peer.
  required bytes candidate_uuid = 2;

  // The term we are requesting a vote for.
  // If this term is higher than the callee's term, the callee will update its
  // own term to match, and if it is the current leader it will step down.
  required uint64 candidate_term = 3;

  // The CANDIDATE node status so that the voter node can
  // decide whether to vote for it as LEADER.
  //
  // In particular, this includes the last OpId persisted in the candidate's
  // log, which corresponds to the lastLogIndex and lastLogTerm fields in Raft.
  // A replica must vote no for a candidate that has an OpId lower than them.
  required ConsensusStatusPB candidate_status = 4;
}

// A response from a replica to a leader election request.
message VoteResponsePB {
  // The uuid of the node sending the reply.
  required bytes responder_uuid = 1;

  // The term of the node sending the reply.
  // Allows the candidate to update itself if it is behind.
  required uint64 responder_term = 2;

  // True if this peer voted for the caller, false otherwise.
  required bool vote_granted = 3;

  // TODO: Migrate ConsensusService to the AppStatusPB RPC style and merge these errors.
  // Error message from the consensus implementation.
  optional ConsensusErrorPB consensus_error = 998;

  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 999;
}

// A consensus request message, the basic unit of a consensus round.
message ConsensusRequestPB {
  required string tablet_id = 1;

  // The uuid of the peer making the call.
  required bytes caller_uuid = 2;

  // The caller's term. As only leaders can send messages,
  // replicas will accept all messages as long as the term
  // is equal to or higher than the last term they know about.
  // If a leader receives a request with a term higher than its own,
  // it will step down and enter FOLLOWER state (see Raft sec. 5.1).
  required uint64 caller_term = 3;

  // The id of the operation immediately preceding the first
  // operation in 'ops'. If the replica is receiving 'ops' for
  // the first time 'preceding_id' must match the replica's
  // last operation.
  //
  // This must be set if 'ops' is non-empty.
  optional OpId preceding_id = 4;

  // The id of the last committed operation in the quorum. This is the
  // id of the last operation the leader deemed committed from a consensus
  // standpoint (not the last operation the leader applied).
  //
  // Raft calls this field 'leaderCommit'.
  required OpId committed_index = 5;

  // Sequence of operations to be replicated by this peer.
  // These will be committed when committed_index advances above their
  // respective OpIds. In some cases committed_index can indicate that
  // these operations are already committed, in which case they will be
  // committed during the same request.
  repeated ReplicateMsg ops = 6;
}

message ConsensusResponsePB {
  // The uuid of the peer making the response.
  optional bytes responder_uuid = 1;

  // The current term of the peer making the response.
  // This is used to update the caller (and make it step down if it is
  // out of date).
  optional uint64 responder_term = 2;

  // The current consensus status of the receiver peer.
  optional ConsensusStatusPB status = 3;

  // A generic error message (such as tablet not found), per operation
  // error messages are sent along with the consensus status.
  optional tserver.TabletServerErrorPB error = 999;
}

// A message reflecting the status of an in-flight transaction.
message TransactionStatusPB {
  required OpId op_id = 1;
  required OperationType tx_type = 2;
  // Time the transaction has been in flight.
  required int64 running_for_micros = 3;
  // Quick human-readable description (e.g., ToString() output).
  required string description = 4;

  required DriverType driver_type = 5;
  // If tracing is enabled when viewing the transaction, the trace
  // buffer is copied here.
  optional string trace_buffer = 6;
}

message GetNodeInstanceRequestPB {
}

message GetNodeInstanceResponsePB {
  required NodeInstancePB node_instance = 1;
}

// Message that makes the local peer LEADER if it isn't so already.
// Assumes that a tablet with 'tablet_id' exists and that the local peer is a
// FOLLOWER of that tablet's quorum. If the peer is already CANDIDATE or
// LEADER of the tablet this has no effect.
message MakePeerLeaderRequestPB {
  // the id of the tablet
  required bytes tablet_id = 1;
}

message MakePeerLeaderResponsePB {
  // A generic error message (such as tablet not found).
  optional tserver.TabletServerErrorPB error = 1;
}

service ConsensusService {
  rpc ChangeConfig(ChangeConfigRequestPB) returns (ChangeConfigResponsePB);

  rpc UpdateConsensus(ConsensusRequestPB) returns (ConsensusResponsePB);

  rpc RequestConsensusVote(VoteRequestPB) returns (VoteResponsePB);

  rpc GetNodeInstance(GetNodeInstanceRequestPB) returns (GetNodeInstanceResponsePB);

  rpc MakePeerLeader(MakePeerLeaderRequestPB) returns (MakePeerLeaderResponsePB);
}
