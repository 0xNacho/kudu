// Copyright (c) 2012, Cloudera, inc.
//
// Protobufs which are common throughout Kudu.
//
// This file may contain protobufs which are persisted on disk
// as well as sent on the wire. If a particular protobuf is only
// used as part of the client-server wire protocol, it should go
// in common/wire_protocol.proto instead. If it is only used within
// the server(s), it should go in cfile/cfile.proto, server/metadata.proto,
// etc, as appropriate.
package kudu;

// If you add a new type keep in mind to add it to the end
// or update AddMapping() functions like the one in key_encoder.cc
// that have a vector that maps the protobuf tag with the index.
//
// TODO: once KeyEncoder is implemented for BOOL, change its
// enum value to 0 (if enum value for BOOL is 0, existing unit tests
// test the KeyEncoder for BOOL, which is not yet implemented).
enum DataType {
  UINT8 = 0;
  INT8 = 1;
  UINT16 = 2;
  INT16 = 3;
  UINT32 = 4;
  INT32 = 5;
  UINT64 = 6;
  INT64 = 7;
  STRING = 8;
  BOOL = 9;
}

enum EncodingType {
  AUTO_ENCODING = 0;
  PLAIN_ENCODING = 1;
  PREFIX_ENCODING = 2;
  GROUP_VARINT = 3;
  RLE = 4;
}

enum CompressionType {
  DEFAULT_COMPRESSION = 0;
  NO_COMPRESSION = 1;
  SNAPPY = 2;
  LZ4 = 3;
  ZLIB = 4;
}

// TODO: Differentiate between the schema attributes
// that are only relevant to the server (e.g.,
// encoding and compression) and those that also
// matter to the client.
message ColumnSchemaPB {
  optional uint32 id = 1;
  required string name = 2;
  required DataType type = 3;
  optional bool is_key = 4 [default = false];
  optional bool is_nullable = 5 [default = false];
  optional bytes read_default_value = 6;
  optional bytes write_default_value = 7;
  optional EncodingType encoding = 8 [default=AUTO_ENCODING];
  optional CompressionType compression = 9 [default=DEFAULT_COMPRESSION];
}

message SchemaPB {
  repeated ColumnSchemaPB columns = 1;
}

message HostPortPB {
  required string host = 1;
  required uint32 port = 2;
}

  // The external consistency mode for client requests.
  // This defines how transactions and/or sequences of operations that touch
  // several TabletServers, in different machines, can be observed by external
  // clients.
  //
  // Note that ExternalConsistencyMode makes no guarantee on atomicity, i.e.
  // no sequence of operations is made atomic (or transactional) just because
  // an external consistency mode is set.
  // Note also that ExternalConsistencyMode has no implication on the
  // consistency between replicas of the same tablet.
enum ExternalConsistencyMode {

    // The server will make no attempt at guaranteeing external
    // consistency.
    //
    // Example:
    // 1 - Client A executes operation X in Tablet A
    // 2 - Afterwards, Client A executes operation Y in Tablet B
    //
    //
    // Client B may observe the following operation sequences:
    // {}, {X}, {Y}, {X Y}, {Y X}
    //
    // This is the default mode.
    NO_CONSISTENCY = 1;

    // The response to any write will contain a timestamp.
    // Any further calls from the same client to other servers will update
    // those servers with that timestamp. The user will make sure that the
    // timestamp is propagated through back-channels to other
    // KuduClient's.
    //
    // WARNING: Failure to propagate timestamp information through
    // back-channels will negate any external consistency guarantee under this
    // mode.
    //
    // Example:
    // 1 - Client A executes operation X in Tablet A
    // 2 - Afterwards, Client A executes operation Y in Tablet B
    //
    //
    // Client B may observe the following operation sequences:
    // {}, {X}, {X Y}
    CLIENT_PROPAGATED = 2;

    // The server will guarantee that each transaction is externally
    // consistent by making sure that none of its results are visible
    // until every Kudu server agrees that the transaction is in the past.
    // The client is not obligated to forward timestamp information
    // through back-channels.
    //
    // WARNING: Depending on the clock synchronization state of TabletServers
    // this may imply considerable latency. Moreover operations with
    // COMMIT_WAIT requested external consistency will outright fail if
    // TabletServer clocks are either unsynchronized or synchronized but
    // with a maximum error which surpasses a pre-configured one.
    //
    // Example:
    // - Client A executes operation X in Tablet A
    // - Afterwards, Client A executes operation Y in Tablet B
    //
    //
    // Client B may observe the following operation sequences:
    // {}, {X}, {X Y}
    COMMIT_WAIT = 3;
};