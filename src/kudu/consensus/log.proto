// Copyright (c) 2013, Cloudera, inc.
package kudu.log;

import "kudu/common/common.proto";
import "kudu/consensus/consensus.proto";
import "kudu/server/metadata.proto";

// ===========================================================================
//  Log Entries - Log specific messages + single node messages
// ===========================================================================

// Types of log entries.
enum LogEntryTypePB {
  OPERATION = 1;
  // Marker entry for dummy log messages. These will never end up in the log,
  // just serve the purpose of making sure that all entries up to the FLUSH_MARKER
  // entry are flushed.
  FLUSH_MARKER = 999;
};

// An entry in the WAL/state machine log.
message LogEntryPB {
  required LogEntryTypePB type = 1;
  optional consensus.OperationPB operation = 2;
}

// A batch of entries in the WAL.
message LogEntryBatchPB {
  repeated LogEntryPB entry = 1;
}

// A header for a log segment.
message LogSegmentHeaderPB {
  // Log format major version.
  required uint32 major_version = 1;

  // Log format minor version.
  required uint32 minor_version = 2;

  // The ID of the tablet this WAL segment stores entries for.
  required bytes tablet_id = 5;

  // The tablet-specific sequence number of this WAL segment.
  required uint64 sequence_number = 6;

  // Schema used when appending entries to this log.
  required SchemaPB schema = 7;
}

// An entry in the footer's sparse index.
// TODO for this to be really useful we need to keep the offset
// of the entry so that we can skip, but since right now this
// is only used to point to the first entry in each segment the
// offset wouldn't really be useful yet.
message SegmentIdxPosPB {
  // The id of the pointed to operation.
  required consensus.OpId id = 1;
}

// A footer for a log segment.
//
// Log segment footers might not be present (e.g. if the server
// crashed) so they should contain no information that cannot
// be obtained by actually reading the entries in the log.
//
// We use the footer to keep sparse index entries mapping
// op_id->offset (right now we just keep the first entry with an
// id in the log)
message LogSegmentFooterPB {
  // the total number of operations inside this segment
  required uint64 num_entries = 1;
  // the ids and the offsets of the batches that contain certain
  // operations within this segment. Right now only points to the
  // first operation with an id.
  // NOTE: It is possible to have a valid segment without any
  // operations with ids.
  repeated SegmentIdxPosPB idx_entry = 2;
}
