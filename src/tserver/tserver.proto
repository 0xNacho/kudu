// Copyright (c) 2013, Cloudera, inc.
package kudu.tserver;

import "common/common.proto";
import "common/wire_protocol.proto";
import "server/metadata.proto";

// Tablet-server specific errors use this protobuf.
message TabletServerErrorPB {
  enum Code {
    // An error which has no more specific error code.
    // The code and message in 'status' may reveal more details.
    //
    // RPCs should avoid returning this, since callers will not be
    // able to easily parse the error.
    UNKNOWN_ERROR = 1;

    // The schema provided for a request was not well-formed.
    INVALID_SCHEMA = 2;

    // The row data provided for a request was not well-formed.
    INVALID_ROW_BLOCK = 3;

    // The mutations or mutation keys provided for a request were
    // not well formed.
    INVALID_MUTATION = 4;

    // The schema provided for a request didn't match the actual
    // schema of the tablet.
    MISMATCHED_SCHEMA = 5;

    // The requested tablet_id is not currently hosted on this server.
    TABLET_NOT_FOUND = 6;

    // A request was made against a scanner ID that was either never
    // created or has expired.
    SCANNER_EXPIRED = 7;

    // An invalid scan was specified -- e.g the values passed for
    // predicates were incorrect sizes.
    INVALID_SCAN_SPEC = 8;

    // The provided configuration was not well-formed and/or
    // had a sequence number that was below the current config.
    INVALID_CONFIG = 9;

    // On a create tablet request, signals that the tablet already exists.
    TABLET_ALREADY_EXISTS = 10;

    // If the tablet has a newer schema than the requested one the "alter"
    // request will be rejected with this error.
    TABLET_HAS_A_NEWER_SCHEMA = 11;
  }

  // The error code.
  required Code code = 1 [ default = UNKNOWN_ERROR ];

  // The Status object for the error. This will include a textual
  // message that may be more useful to present in log messages, etc,
  // though its error code is less specific.
  required AppStatusPB status = 2;
}


message PingRequestPB {
}

message PingResponsePB {
}

message AlterSchemaRequestPB {
  required bytes tablet_id = 1;

  // TODO: Replace with the table descriptor
  // (Schema, Column IDs, Column Attributes)
  required SchemaPB schema = 2;

  required uint32 schema_version = 3;
}

message AlterSchemaResponsePB {
  optional TabletServerErrorPB error = 1;
}

// A batched set of insert/mutate requests.
// TODO currently we're sending the client schema multiple times in each
// row block.
message WriteRequestPB {
  required bytes tablet_id = 1;

  optional SchemaPB schema = 2;

  // Set of rows to insert.
  optional PartialRowsPB to_insert_rows = 3;

  // Set of row keys to mutate.  This rowblock's schema should contain
  // only the key columns
  optional RowwiseRowBlockPB to_mutate_row_keys = 4;
  // Mutations to apply to the row keys in mutate_data.
  // Uses the encoded format from the RowChangeList class.
  optional bytes encoded_mutations = 5;
}

message WriteResponsePB {
  // If the entire WriteResponsePB request failed, the error status that
  // caused the failure. This type of error is triggered for
  // cases such as the tablet not being on this server, or the
  // schema not matching. If any error specific to a given row
  // occurs, this error will be recorded in per_row_errors below,
  // even if all rows failed.
  optional TabletServerErrorPB error = 1;

  // If errors occurred inserting particular rows, then the errors
  // for those rows will be passed back in 'per_row_errors'.
  message PerRowErrorPB {
    // whether the error refers to an insertion or mutation.
    required bool is_insert = 1;
    // The index of the row in the incoming batch.
    required int32 row_index = 2;
    // The error that occurred.
    required AppStatusPB error = 3;
  }
  repeated PerRowErrorPB per_row_errors = 2;
}

// A create tablet request.
message CreateTabletRequestPB {
  required bytes table_id = 1;
  required bytes tablet_id = 2;
  required bytes start_key = 3;
  required bytes end_key = 4;
  required SchemaPB schema = 5;
  // Optional quorum for the tablet. If one is not provided a local quorum
  // is chosen.
  optional metadata.QuorumPB quorum = 6;
}

message CreateTabletResponsePB {
  optional TabletServerErrorPB error = 1;
}

// A configuration change request for the tablet with 'tablet_id'.
message ChangeConfigRequestPB {
  required bytes tablet_id = 1;

  // The old config seqno to perform CAS style quorum config changes.
  optional int64 old_config = 2;

  // The new configuration to set the quorum to.
  required kudu.metadata.QuorumPB new_config = 3;
}

// The configuration change response. If any immediate error occurred
// the 'error' field is set with it.
message ChangeConfigResponsePB {
  optional TabletServerErrorPB error = 1;
}

// A range predicate on one of the columns in the underlying
// data.
message ColumnRangePredicatePB {
  required ColumnSchemaPB column = 1;

  // These bounds should be encoded as follows:
  // - STRING values: simply the exact string value for the bound.
  // - other type: the canonical x86 in-memory representation -- eg for
  //   uint32s, a little-endian value.
  //
  // Note that this predicate type should not be used for NULL data --
  // NULL is defined to neither be greater than or less than other values
  // for the comparison operator. We will eventually add a special
  // predicate type for null-ness.
  optional bytes lower_bound = 2;
  optional bytes upper_bound = 3;
}

message NewScanRequestPB {
  // The tablet to scan.
  required bytes tablet_id = 1;

  // The maximum number of rows to scan.
  // The scanner will automatically stop yielding results and close
  // itself after reaching this number of result rows.
  optional uint64 limit = 2;

  // Any column range predicates to enforce.
  repeated ColumnRangePredicatePB range_predicates = 3;

  // Which columns to select.
  // if this is an empty list, no data will be returned, but the num_rows
  // field of the returned RowBlock will indicate how many rows passed
  // the predicates. Note that in some cases, the scan may still require
  // multiple round-trips, and the caller must aggregate the counts.
  repeated ColumnSchemaPB projected_columns = 4;

  // TODO: add some field which requests ordered results (which has
  // the side effect of being able to be fault-tolerant)
}

// A scan request. Initially, it should specify a scan. Later on, you
// can use the scanner id returned to fetch result batches with a different
// scan request.
//
// The scanner will remain open if there are more results, and it's not
// asked to be closed explicitly.
//
// You can fetch the results and ask the scanner to be closed to save
// a trip if you are not interested in remaining results.
//
// This is modeled somewhat after HBase's scanner API.
message ScanRequestPB {
  // If continuing an existing scan, then you must set scanner_id.
  // Otherwise, you must set 'new_scan_request'.
  optional bytes scanner_id = 1;
  optional NewScanRequestPB new_scan_request = 2;

  // The sequence ID of this call. The sequence ID should start at 0
  // with the request for a new scanner, and after each successful request,
  // the client should increment it by 1. When retrying a request, the client
  // should _not_ increment this value. If the server detects that the client
  // missed a chunk of rows from the middle of a scan, it will respond with an
  // error.
  optional uint32 call_seq_id = 3;

  // The maximum number of bytes to send in the response.
  // This is a hint, not a requirement: the server may send
  // arbitrarily fewer or more bytes than requested.
  optional uint32 batch_size_bytes = 4;

  // If set, the server will close the scanner after responding to
  // this request, regardless of whether all rows have been delivered.
  // In order to simply close a scanner without selecting any rows, you
  // may set batch_size_bytes to 0 in conjunction with setting this flag.
  optional bool close_scanner = 5;
}

message ScanResponsePB {
  // The error, if an error occurred with this request.
  optional TabletServerErrorPB error = 1;

  // When a scanner is created, returns the scanner ID which may be used
  // to pull new rows from the scanner.
  optional bytes scanner_id = 2;

  // Set to true to indicate that there may be further results to be fetched
  // from this scanner. If the scanner has no more results, then the scanner
  // ID will become invalid and cannot continue to be used.
  //
  // Note that if a scan returns no results, then the initial response from
  // the first RPC may return false in this flag, in which case there will
  // be no scanner ID assigned.
  optional bool has_more_results = 3;

  // The block of returned rows.
  //
  // NOTE: the schema-related fields will not be present in this row block.
  // The schema will match the schema requested by the client when it created
  // the scanner.
  optional RowwiseRowBlockPB data = 4;
}
