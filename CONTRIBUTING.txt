Code style
-----------------------------

In general, Kudu follows the Google C++ Style Guide:
http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml

There are a few exceptions where we depart from the above:

- Use of boost is permitted but mostly discouraged.

Boost libraries may be used in cases where we don't have a suitable
replacement in our own code-base. However, try to avoid introducing
dependencies on new boost libraries, and use our own code in preference
to boost where available. For example, do not use boost's scoped pointer
implementations.

The most commonly used Boost libraries, which are fine to use are:

- BOOST_FOREACH
- boost::assign (container literals)
- boost::mutex and boost::shared_mutex (though consider our own
  spin lock implementation for short critical sections)
- boost::bind (for callbacks)

Check that any features from boost you use are present in boost 1.46
or earlier, for compatibility with RHEL6.

- Line length: up to 100 characters is OK

The google guide says 80 characters, but that's a little short. Try to
keep under 80 where possible, but if you spill over to ~100 or so, not
a big deal.

- Smart pointers and singly-owned pointers:

Generally, most objects should have clear "single-owner" semantics.
Most of the time, singly-owned objects can be wrapped in a gscoped_ptr<>
which ensures deletion on scope exit and prevents accidental copying.
gscoped_ptr is similar to C++11's unique_ptr in that it has a release()
method and also provides emulated move semantics (see gscoped_ptr.h for
example usage).

Sometimes objects are singly owned, but referenced from multiple places --
for example, when the pointed-toobject is known to be valid at least as long
as the pointer itself. In these cases, you should have a comment associated
with the constructor which takes and stores the raw pointer, eg:

  // 'blah' must remain valid for the lifetime of this class
  MyClass(const Blah* blah) :
    blah_(blah) {
  }

Another case where raw pointers are necessary is within STL collections.
You may use raw pointers inside of vectors and other containers. The
containers should have an associated comment explaining the ownership
semantics (owned or un-owned). Use utility code from gutil/stl_util.h (eg
STLDeleteElements or ElementDeleter) to easily handle deletion of the
contained elements.

Note that std::auto_ptr is strictly disallowed -- its semantics are hard
to reason about and bug-prone.

- Smart pointers for multiply-owned pointers:

Although you should always strive for single ownership, sometimes it is
not possible -- particularly when multiple threads are in play and the
lifetimes of the pointers aren't clear. In these cases, you can use either
std::tr1::shared_ptr or our own scoped_refptr from gutil/ref_counted.hpp.
Both of these mechanisms rely on reference counting to automatically delete
the referrent once no more pointers remain. The key difference between
these two types of pointers is that scoped_refptr requires that the object
extend a RefCounted base class, and stores its reference count inside the
object storage itself. shared_ptr on the other hand maintains a separate
reference count on the heap.

The pros and cons are:

shared_ptr:
  pro: can be used with any type of object, without the object deriving from
       a special base class
  pro: part of the standard library and familiar to most C++ developers
  con: creating a new object requires two allocations instead of one
       (one to create the ref count, and one to create the object)
  con: the ref count may not be near the object on the heap, so extra cache
       misses may be incurred on access
  con: the shared_ptr instance itself requires 16 bytes (pointer to the ref
       count and pointer to the object)
  con: if you convert from the shared_ptr to a raw pointer, you can't get
       back the shared_ptr

scoped_refptr:
  pro: only requires a single allocation, and ref count is on the same cache
       line as the object
  pro: pointer only requires 8 bytes (since the ref count is with the object)
  pro: may manually increase/decrease reference counts when more control is
       required
  pro: may convert from a raw pointer back to a scoped_refptr safely without
       worrying about double freeing
  pro: since we control the implementation we could easily implement features
       like debug builds that capture the stack trace of every referrent
       to help debug leaks, etc.
  con: referred-to object must inherit from RefCounted
  con: does not support weak_ptr<> use cases

Given that scoped_refptrs are generally faster and smaller, prefer using them
over shared_ptr in new code. Existing code (as of 12/20/2013) uses shared_ptrs
in many places -- when interfacing with that code, continued use of shared_ptr
is fine.

-CMake Style Guide

CMake allows commands in lower, upper, or mixed case. Therefore to keep
the CMake files consistent, please use the following guidelines:

-built-in commands in lowercase
add_subdirectory(some/path)

-built-in arguments in uppercase
message(STATUS "message goes here")

-custom commands/macros in uppercase
ADD_KUDU_TEST(some-test)


Testing guidelines
-----------------------

All new code should have tests. Add new tests either in existing
files, or create new test files as necessary.

All bug fixes should have tests. It's OK to fix a bug without adding a
new test if it's triggered by an existing test case. For example, if a
race shows up when running a multi-threaded system test after 20
minutes or so, it's worth trying to make a more targeted test case to
trigger the bug. But, if that's hard to do, the existing system test
should be enough.

Tests should run quickly (< 1s). If you want to write a time-intensive
test make the runtime dependent on KuduTest#AllowSlowTests, which is
be enabled via the KUDU_ALLOW_SLOW_TESTS environment variable (and is
used by Jenkins test execution).

Tests which run a number of iterations of some task can use gflags to
take the number of iterations on the command line. This is handy for
writing quick stress tests or performance tests.

Commits which may affect performance should include before/after
perf-stat(1) output for a test case which shows the performance
improvement, or shows the non-regression of performance. Performance
sensitive code should include some test case which can be used as a
targeted benchmark.
